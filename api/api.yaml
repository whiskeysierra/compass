swagger: '2.0'
info:
  title: Compass - Configuration Management API
  description: |
    Compass is a configuration service with a multi-dimensional key space. Every value is identified by at exactly one
    key and an arbitrary number of additional dimensions. As an example it would allow to define a key `tax-rate` and
    specify different values per country (dimension) as well as before (time dimension):

    | Key      | Country | Before                    | Value |
    |----------|---------|---------------------------|-------|
    | tax-rate | DE      | 2007-01-01T00:00:00+02:00 | 0.16  |
    | tax-rate | DE      |                           | 0.19  |
    | tax-rate | AT      |                           | 0.20  |
    | tax-rate | CH      |                           | 0.08  |

    Different dimension my influence how values are queried. The `country` dimension is matched based on equality (`=`)
    while the `after` dimension is based on inequality or to be more precise less than (`<`). That property is called
    relation and they can't be created using this API - in contrast to keys and dimensions.

    Keys can impose certain type restrictions on their values by defining a JSON schema. The same applies to dimensions
    and their values.
  version: "0.1.0"
schemes:
  - https
consumes:
  - application/json
produces:
  - application/json
  - application/problem+json
tags:
  - name: relations
  - name: dimensions
  - name: keys
  - name: values
  - name: value
paths:
  /relations:
    get:
      tags: [relations]
      summary: Read all relations
      description: |
        Read the complete list of all relations available at this point in time. A relation specifies how the values
        of a dimension are matched when being queried. Useful relations would be equality (=), greater-than (>),
        less-than (<) and so forth.
      responses:
        200:
          description: OK
          schema:
            $ref: '#/definitions/RelationPage'
  /relations/{relation}:
    get:
      tags: [relations]
      summary: Read a single relation.
      parameters:
        - name: relation
          in: path
          type: string
          required: true
      responses:
        200:
          description: OK
          schema:
            $ref: '#/definitions/Relation'
  /dimensions:
    get:
      tags: [dimensions]
      summary: Read all dimensions
      description: |
        Read the complete list of all dimensions currently defined. This is intended to be used for display purposes.
      responses:
        200:
          description: OK
          schema:
            $ref: '#/definitions/DimensionPage'
  /dimensions/{dimension}:
    put:
      tags: [dimensions]
      summary: Replace a dimension
      description: |
        Either create a new dimension or update an existing one.

        A modification to an existing dimension's schema requires that all values that are using this dimension
        successfully validate against it. A violation of this rule will result in a rejected update.
      parameters:
        - $ref: '#/parameters/DimensionId'
        - name: dimension
          in: body
          schema:
            $ref: '#/definitions/Dimension'
      responses:
        200:
          description: OK
          schema:
            $ref: '#/definitions/Dimension'
        201:
          description: Created
          schema:
            $ref: '#/definitions/Dimension'
    get:
      tags: [dimensions]
      summary: Read a dimension
      parameters:
        - $ref: '#/parameters/DimensionId'
      responses:
        200:
          description: OK
          schema:
            $ref: '#/definitions/Dimension'
    delete:
      tags: [dimensions]
      summary: Delete a dimension
      description: Deleting a dimension that is still referenced by a value is not supported and will be rejected.
      parameters:
        - $ref: '#/parameters/DimensionId'
      responses:
        204:
          description: No Content
  /keys:
    get:
      tags: [keys]
      summary: Read all keys
      responses:
        200:
          description: OK
          schema:
            $ref: '#/definitions/KeyPage'
  /keys/{key}:
    put:
      tags: [keys]
      summary: Replace a key
      description: |
        Either create a new key or update an existing one.

        A modification to an existing key's schema requires that all values of this key successfully validate against
        it. A violation of this rule will result in a rejected update.
      parameters:
        - $ref: '#/parameters/Key'
        - name: key
          in: body
          schema:
            $ref: '#/definitions/Key'
      responses:
        200:
          description: OK
          schema:
            $ref: '#/definitions/Key'
        201:
          description: Created
          schema:
            $ref: '#/definitions/Key'
    get:
      tags: [keys]
      summary: Read a key
      parameters:
        - $ref: '#/parameters/Key'
      responses:
        200:
          description: OK
          schema:
            $ref: '#/definitions/Key'
    delete:
      tags: [keys]
      summary: Delete a key
      description: Deleting a key will delete all of its values.
      parameters:
        - $ref: '#/parameters/Key'
      responses:
        204:
          description: No Content
  /keys/{key}/values:
    put:
      tags: [values]
      summary: Replace all values for the given key.
      description: |
        If any value violates this key's schema or any dimensions values are violating their respective dimension's
        schema then the whole update will be rejected.
      parameters:
        - $ref: '#/parameters/Key'
        - name: values
          in: body
          required: true
          schema:
            $ref: '#/definitions/ValuePage'
      responses:
        200:
          description: OK
          schema:
            $ref: '#/definitions/ValuePage'
    post:
      tags: [values]
      summary: Add a value for the given key
      description: |
         If the value violates this key's schema or any dimensions values are violating their respective dimension's
         schema then the update will be rejected.
      parameters:
        - $ref: '#/parameters/Key'
        - name: value
          in: body
          schema:
            $ref: '#/definitions/Value'
      responses:
        200:
          description: OK
          schema:
            $ref: '#/definitions/ValuePage'
        201:
          description: Created
          schema:
            $ref: '#/definitions/ValuePage'
    get:
      tags: [values]
      summary: Read values for the given key and optional dimension
      description: |
        Values can either be read as a whole or being filtered by dimensions:

        - `GET /keys/tax-rate/values`, all tax rates
        - `GET /keys/tax-rate/values?country=DE`, all tax rates for Germany
        - `GET /keys/tax-rate/values?country=DE&after=2015-09-07T16:00:00`, all tax rates for Germany that are valid after 2015-09-07T16:00:00

        Values are always returned in insertion order. Ordering can be changed by replacing all values.
      parameters:
        - $ref: '#/parameters/Key'
        - $ref: '#/parameters/Filter'
      responses:
        200:
          description: OK
          schema:
            $ref: '#/definitions/ValuePage'
  /keys/{key}/value:
    put:
      tags: [value]
      summary: Replace value of the given key
      description: |
        Replaces a value that is unambiguously identified by the given key and dimensions. In contrast to reading a
        value this endpoint does not select the best match but rather requires an exact match.

        Replacing a value with country: DE and after: 2015-09-07T16:17:21 will NOT replace a value that is configured
        with the after: 2015-09-07T16:00:00, but rather create a new one.
        Replacing country: DE and after: 2015-09-07T16:00:00 on the other would update it.

        As a general statement: Reading is (or can be) fuzzy, but updates and deletes are not.
      parameters:
        - $ref: '#/parameters/Key'
        - name: value
          in: body
          required: true
          schema:
            $ref: '#/definitions/Value'
      responses:
        200:
          description: OK
          schema:
            $ref: '#/definitions/Value'
    get:
      tags: [value]
      summary: Read a value of the given key and optional dimensions
      description: |
        Reads the best matching value for the given key and dimensions:

        - `GET /keys/tax-rate/value`, tax rate that applies to all country (probably none, so `404 Not Found`)
        - `GET /keys/tax-rate/value?country=DE`, tax rate for Germany
        - `GET /keys/tax-rate/value?country=DE&after=2015-09-07T16:00:00`, tax rate for Germany that are valid after 2015-09-07T16:00:00

        Values have an explicit ordering that can be changed by replacing all values. Selecting the best value for
        a given key and selected dimensions is based on that order. The first match will be returned. That implies
        that values should be ordered from fine- to coarse-grained or from specific to generic.
      parameters:
        - $ref: '#/parameters/Key'
        - $ref: '#/parameters/Filter'
      responses:
        200:
          description: OK
          schema:
            $ref: '#/definitions/Value'
    delete:
      tags: [value]
      summary: Delete a value
      description: |
        Deletes a value that is unambiguously identified by the given key and dimensions. In contrast to reading a
        value this endpoint does not select the best match but rather requires an exact match.

        `DELETE /keys/tax-rate/value?country=DE&after=2015-09-07T16:17:21` will NOT delete a value that is configured
        with the `after=2015-09-07T16:00:00`, but `DELETE /keys/tax-rate/value?country=DE&after=2015-09-07T16:00:00`
        would.

        As a general statement: Reading is (or can be) fuzzy, but updates and deletes are not.
      parameters:
        - $ref: '#/parameters/Key'
        - $ref: '#/parameters/Filter'
      responses:
        204:
          description: No Content
  /values:
    get:
      tags: [values]
      summary: Read all values and filter by key pattern
      parameters:
        - name: q
          description: Key pattern
          in: query
          type: string
      responses:
        200:
          description: OK
          schema:
            type: object
            additionalProperties:
              type: array
              items:
                $ref: '#/definitions/Value'
            example:
              active:
                - dimensions:
                    email: '.*@qa-example.com'
                    value: true
                - dimensions:
                  value: false
              tax-rate:
                - dimension:
                    country: DE
                  value: 0.19
                - dimension:
                    country: CH
                  value: 0.08
parameters:
  DimensionId:
    name: dimension
    in: path
    type: string
    required: true
  Key:
    name: key
    in: path
    type: string
    required: true
  Filter:
    name: '' # we have to specify a name here even though we support any and many of them.
    description: |
      A dynamic number of dimensions, e.g. `country=AT&after=2015-09-07T16:00:00`. The values have to match the schema
      specified by their corresponding dimension. The correct JSON type is deducted based on "appearance" of the value,
      e.g. if a value looks like a boolean it will be parsed as one. In order to prevent incorrect typing, e.g.
      the value `true` should be parsed as a string, it needs to be wrapped in double quotes, `"true"`.
    in: query
    type: array
    items: {}
    collectionFormat: multi
definitions:
  RelationPage:
    type: object
    properties:
      relations:
        type: array
        items:
          $ref: '#/definitions/Relation'
    required:
      - relations
  Relation:
    type: object
    properties:
      id:
        description: The unique identifier for this relation.
        type: string
        minLength: 1
        example: =
      title:
        description: The readable name for this relation
        type: string
        minLength: 1
        example: equality
      description:
        description: |
          A description of this relation that should define what characteristics is has in terms of matching values.
        type: string
        minLength: 1
    required:
      - id
      - title
      - description
  ID:
    type: string
    pattern: '^([a-z0-9]+(-[a-z0-9]+)*)(\.([a-z0-9]+(-[a-z0-9]+)*))*$'
    example: country
  DimensionPage:
    type: object
    properties:
      dimensions:
        type: array
        items:
          $ref: '#/definitions/Dimension'
    required:
      - dimensions
  Dimension:
    type: object
    properties:
      id:
        description: The unique identifier for this dimension.
        $ref: '#/definitions/ID'
        readOnly: true
        example: country
      schema:
        description: The schema that applies to all values of this dimension across all values.
        $ref: 'http://json-schema.org/schema#'
        example:
          type: string
          pattern: '^[A-Z]{2}$'
      relation:
        description: |
          The underlying operator that is used to apply any matching and ordering semantics. For a complete list of
          available relations, use `GET /relations`.
        type: string
        example: =
      description:
        description: |
          A description of this key that should define what the dimension is about and what possible values it can have.
          Alternatively this can be a URL to an accessible web page.
        type: string
        minLength: 1
        example: ISO 3166-1 alpha-2 country code, see https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2#Officially_assigned_code_elements
    required:
      - schema
      - relation
      - description
  KeyPage:
    type: object
    properties:
      keys:
        type: array
        items:
          $ref: '#/definitions/Key'
    required:
      - keys
  Key:
    type: object
    properties:
      id:
        description: The unique identifier for this key. It can be namespaced.
        $ref: '#/definitions/ID'
        readOnly: true
        example: tax-rate
      schema:
        description: The schema that applies to all values of this key.
        $ref: 'http://json-schema.org/schema#'
        example:
          type: number
          format: decimal
          min: 0.0
          max: 1.0
      description:
        type: string
        description: |
          A description of this key that should define what the key is about. Alternatively this can be a 
          URL to an accessible web page.
        minLength: 1
        example: Tax rate as a factor in the range [0,1].
    required:
      - schema
      - description
  ValuePage:
    type: object
    properties:
      values:
        type: array
        items:
          $ref: '#/definitions/Value'
  Value:
    type: object
    properties:
      dimensions:
        type: object
        # keys are dimension identifiers
        # values are typed according to the dimension's schema
        additionalProperties: true
        example:
          country: DE
          after: 2017-01-01T00:00:00
        default: {}
      value:
        description: |
          Actual value for this key and its dimensions. This may be of any type, i.e. everything from primitive values like boolean and integers to complex
          structures is possible. Although complex objects can usually be flattened with the use of custom dimensions very efficiently.
        example: 0.2
    required:
      - value
    example:
      dimensions:
        country: DE
        after: 2017-01-01T00:00:00
      value: 0.2